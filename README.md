# react-mini-algorithm
JS实现最小堆和偏排序算法

### 目标：

1. 掌握最小堆
2. 掌握偏排序



### 找出第K大的数字

[4，5，8，2 ...]

这个时候，你可能很容想到用数组的sort方法排序来解决

```javascript
const sortArr = arr.sort((a, b) => b - a )
```

那么第K大的数字就是`sortArr[k-1]`

但如果有1000万个乱序的数字呢，很明显当数据量很大的时候再采取这种全排序的方法则不合适了。

举个例子，我想在北京找一家最好吃的早餐店，但北京可能有10万个早餐店，甚至1000万个，假如北京有10万个早餐店，我就想要第二大好吃的，我不要第一大，我就要第二大，排名排到第二的，那么怎么找呢？肯定不可能像上面那样从1到10万这样全排序，那得多耗时间啊！

这个时候，相对全排序，有一个叫偏排序的方法，则非常合适，那么什么叫偏排序呢？

找出这些数字里前K名的大数字，后面的小数字则不要了，也就是说只要给前K名的数字做个排序的就可以了，但也不用全排序，就算前K名的数字也不用全排序，只要这个前K名最小的就可以了，也就是只要将这前K名的数字做个最小堆的数据结构，拿出最小的数字就可以了


了解最小堆之前，我们先要了解以下概念：

### 二叉树

是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。

### 满二叉树

除最后一层无任何子节点外，每一层的所有结点都有两个子结点的二叉树。

从图形形态上看，满二叉树外观上是一个三角形。

如果一个二叉树的层数为K，且结点总数是(2^k)-1，则它就是满二叉树。

 ![](./md/full-binary-tree.png)



### 完全二叉树

一棵深度为K的有n个结点的二叉树，对树中的结点按从上至下，从左到右的顺序进行编号，如果编号为i(1sisn)的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

叶子结点只可能在最大的两层出现。

 ![](./md/complete-binary-tree.png)

如果上面的11的节点不存在，那么整棵树就不是完全二叉树了，可以从右边缺，但不能从左边缺。所以即便12没有了，也还是一棵完全二叉树。

接下来，我们说下一个概念：

### 最小堆

最小堆，是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值

 ![](./md/Min-Heap.png)

每一个子树都满足根节点最小，没有14也是最小堆，但没有15，14还在则不是最小堆了，因为它已经不是一棵完全二叉树了。


### 最小堆的数据结构

在JS中我们可以选择数组来作为最小堆的数据结构


| 数组     | 3    | 7    | 4    | 10   | 12   | 9    | 6    | 15   | 14   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 深度     | 1    | 2    | 2    | 3    | 3    | 3    | 3    | 4    | 4    |
| 数组下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |



#### 根据父节点下标推算子节点下标：

leftIndex = (parentIndex + 1) * 2 - 1

rightIndex = leftIndex + 1



#### 根据子节点下标推算父节点下标：

parentIndex = (childIndex - 1) >>> 1



节点操作：

1. 获取最小节点 heap[0]
2. 插入元素
3. 删除元素



插入元素5

1. 因为5 < 12，则5与12交换位置，5从底部向上调整
2. 5 < 7，5与7交换位置，继续往上调整
3. 5 > 3，停止调整

删除元素

1. 先取heap[0]
2. 为了不破坏数据结构，可以执行数组的pop，把尾元素14放到heap[0]，但是这个时候已经不是最小堆了，需要往下调整
3. 从0位置节点开始往下调整，与左右节点比较，找出最小，如先与4交换
4. 再与6交换
5. 完成





